#!/bin/sh

# Config
dir_icon=
file_icon=
prompt="Choose File/Directory: "
height_with_preview=99
height_no_preview=55
preview_window_height=55

# Defaults
defaultpath="."
mindepth=1
maxdepth=6
output_full_path=true

# Parse opts and args
opts=$(
    getopt --shell sh --unquoted \
    \
    --opt hP:d:D:mp \
    --longopt help,path:,mindepth:,maxdepth:,multi,preview \
    \
    --name hotfuzz -- "$@"
    )

[ "$?" != 0 ] && echo "terminating..." >&2 && exit 1
eval set -- "$opts"

# Commands to remove icons and extra stuff from filename
trim_filename_cmd="tr -d "${dir_icon}${file_icon}" | cut -c2-"

# fzf preview command
fzf_preview="echo "{}" | $trim_filename_cmd | \
    xargs -I{x} quickscope --cybermime --name {x} 20"

# fzf Options
fzf_opts='
--prompt="'"$prompt"'"
--layout=reverse --height="'"$height_no_preview"'%"
--bind "ctrl-d:half-page-down,ctrl-u:half-page-up,ctrl-g:top,ctrl-p:toggle-preview"
'
fzf_preview_opts='
--height="'"$height_with_preview"'%"
--preview="'"$fzf_preview"'"
--preview-window="down:'"$preview_window_height"'%:rounded"
'
fzf_multi_opt='
--multi
'

# Handle opts
while true; do
    case "$1" in
        -h | --help     ) echo "fuzzy file finder"; exit 0 ;;
        -D | --maxdepth ) maxdepth="$2";     shift 2 ;;
        -d | --mindepth ) mindepth="$2";     shift 2 ;;
        -m | --multi    ) fzf_opts="$fzf_opts $fzf_multi_opt";    shift ;;
        -p | --preview  ) fzf_opts="$fzf_opts $fzf_preview_opts"; shift ;;
        -f | --no-fullpath ) full_path=false; shift ;;
        -P | --path     ) findpath="${findpath}${2}
";                        shift 2 ;;
        -- ) shift; break ;;
        *  ) break        ;;
    esac
done

# Handle paths that are passed without args
if [ -n "$*" ]; then
    findpath=""
    while [ -n "$1" ]; do
        findpath="${findpath}${1}
"
        shift
    done
else
    findpath="$defaultpath"
fi

# Test if path exists
echo -E "$findpath" | awk NF | while IFS= read -r path; do
    [ ! -d "$path" ] &&
        echo -e "hotfuzz: a given path does not exist\nterminating..." >&2 &&
        exit 1
done

# Test if maxdepth is an integer and is in range
case "$maxdepth" in
    ''|*[!0-9]*)
        echo -e "hotfuzz: maxdepth is not an integer\nterminating..." >&2 &&
        exit 1 ;;
    *)
        if [ "$maxdepth" -gt 30 ] || [ "$maxdepth" -lt 1 ]; then
            echo -e "hotfuzz: maxdepth is too big\nterminating..." >&2 &&
            exit 1
        fi ;;
esac

# Test if search is from current working directory
[ "$findpath" = "." ] && cwd=true

# The find function
findfn() {
    local path="$1"
    local depth="$2"
    local type="$3" #type can be d (for directory) or f (for file)
    [ "$cwd" = true ] && cutarg='-c3-' || cutarg='-c1-'
    [ "$type" = 'd' ] && icon="$dir_icon" || icon="$file_icon"
    /usr/bin/find -L "$path" -mindepth $depth -maxdepth $depth -type $type \
        -not -path '*/\.git/*'  \
        -not -name '.git'       \
        -not -path '*/\.surf/*' \
        -not -name '.surf'      \
        2>/dev/null | cut "$cutarg" | awk -v icon="$icon" '{print icon" "$0}'
}

# fzf Options
FZF_DEFAULT_OPTS="$fzf_opts"

if [ "$output_full_path" = true ] &&
   [ "$(echo "$findpath" | wc -l )" == 1 ] &&
   [ "$(echo "$findpath" | cut -c1)" != "/" ]
then
    full_path_cmd="awk -v pwd=$PWD '{print pwd \"/\" \$0}'"
else
    full_path_cmd="cat"
fi

# Loop through depths from shallow to deep
for (( depth = $mindepth; depth <= $maxdepth; depth++ )); do
    echo -E "$findpath" | awk NF | while IFS= read -r path; do
        findfn "$path" "$depth" f
        findfn "$path" "$depth" d
    done
done | fzf | eval "$trim_filename_cmd" | eval "$full_path_cmd"
