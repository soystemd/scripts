#!/bin/bash
# Koonix 2020-08-23
# This script be responsible for me statusbar.

##############################################################################
# Configuration
##############################################################################
#
# Bar update interval
interval=8
#
# The delimiter character(s) between widgets
# The escape sequences \x01 through \x06 represent colors
delimiter="\x05 ][ \x06"
#
# The half-delimiter at the end of the bar
enddelimiter="\x05 ]"
#
# Whatever you want to show up at the beginning of the bar
bar_prefix=" "
#
# Glyphs/Emojis
glyph_headphone=""
glyph_keyboard=""
glyph_speaker=""
glyph_memory=""
glyph_geoip=""
glyph_geoip_tor=""
glyph_break=""
glyph_temp=""
glyph_time=""
glyph_play=""
#
# Position of widgets
widpos_timedate="\
    1"
#widpos_break="\
#    2"
widpos_kblayout="\
    2"
widpos_audio="\
    3"
widpos_geoip="\
    4"
widpos_mem="\
    5"
#
##############################################################################
# End of Configuration
##############################################################################

# Main function
main() {
    case "$1" in
        -h | --help) echo "statusbar script for suckless's dwm"; exit 0 ;;
    esac
    # Refresh the statusbar
    while true ; do
        refresh_bar_all
        sleep "$interval" &
        wait
    done
}

#############
# FUNCTIONS #
#############

######
# Construct the statusbar
refresh_widgets_all() {

    # All the widgets
    refresh_widgets_set1

    # Volume and keyboard-layout widgets
    refresh_widgets_set2

    # Geoip widget
    refresh_widgets_set3
}

# Construct the statusbar while updating only some of the widgets
refresh_widgets_set1() {

    # Time and date widget
    WIDGET[$widpos_timedate]=$(widget_timedate)

    # Memory usage widget
    WIDGET[$widpos_mem]=$(widget_mem)
}

# Construct the statusbar while updating only some of the widgets
refresh_widgets_set2() {

    # Keyboard layout widget
    WIDGET[$widpos_kblayout]=$(widget_kb_layout)

    # Audio widget
    WIDGET[$widpos_audio]=$(widget_audio)

    # Time left till next eagle break
#    WIDGET[$widpos_break]=$(widget_break)
}

# Construct the statusbar while updating only some of the widgets
refresh_widgets_set3() {

    # Geoip widget
    WIDGET[$widpos_geoip]=$(widget_geoip)
}
######


######
# Widget that shows time and date.
widget_timedate() {

    echo "$(date -Im | \
        awk -v glyph="$glyph_time" 'BEGIN{FS=OFS="+"} \
        {gsub(/T/, " x ", $1); print glyph " " $1}')"
}

# Widget that shows the current keyboard layout.
widget_kb_layout() {

    echo "$glyph_keyboard"; echo "$(xkblayout-state print " %s")"; echo
}

# Widget that shows some audio related stuff.
widget_audio() {

    # Check if audio is playing through headphones or speakers
    currentsink=$(vol-getcurrentsinkname)
    if [[ $currentsink = analog-stereo ]]
    then
        sinkicon="$glyph_headphone"
    else
        sinkicon="$glyph_speaker"
    fi

    # Check if mpd is playing music
    playing=" $glyph_play"
    [ -z "$(mpc | awk '/\[playing\]/')" ] &&\
        playing=""

    echo "${sinkicon} "; echo "$(vol-getcurrentvolumeandmute)${playing}"
}

# Widget that shows memory usage.
widget_mem() {

    load=$(top -bn1 | grep "Cpu(s)" | \
           sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | \
           awk '{print 100 - $1}'|\
           awk 'BEGIN{FS="."}{print $1}')

# Show glyphs based on cpu load percentage  
    verbal=$(case 1 in
    $(($load>= 90 )))echo "";;
    $(($load>= 70 )))echo ""   ;;
    $(($load>= 50 )))echo "" ;;
    $(($load>= 30 )))echo ""    ;;
                   *)echo ""   ;;
    esac)

    echo "$(free -h | \
        awk -v glyph="$glyph_memory"\
        -v verb="$verbal"\
        '/^Mem:/ {print glyph" "$3" "verb}')"
}

# Widget that shows CPU temp.
widget_cpu() {
    local cpu="$(sensors | \
        awk -v glyph="$glyph_temp" '/^Core 0/ {print glyph $3}' | tr '+' ' ')"
    echo "${cpu::-4}°C"
}

widget_break() {
    local time_left_till_nextbreak=$(cat /tmp/eagle-${USER})
    [ "$time_left_till_nextbreak" = "pause" ] &&\
        time_left_till_nextbreak=""
    echo "$glyph_break $time_left_till_nextbreak"
}

# Widget that shows your location based on your public ip.
widget_geoip() {

    local ip_direct=$(\
        curl -s --retry 1 ifconfig.me || echo "")

    local ip_tor=$(\
        curl -x socks5://127.0.0.1:9050 -s --retry 1 ifconfig.me || echo "")

    if [ "$ip_direct" = "" ] && [ "$ip_tor" = "" ]; then
        echo "$ip_direct"
    else
        geoip_direct=$(geoiplookup "$ip_direct")
        geoip_tor=$(geoiplookup "$ip_tor")

        geoip_direct="$(echo "$geoip_direct" | \
            awk \
                -v glyph="$glyph_geoip"\
                'BEGIN { FS=OFS="," }\
                /^GeoIP/ {gsub(/Iran/, "ir", $2);\
                print glyph tolower($2) " "}')"

        [ -n "$glyph_geoip_tor" ] &&\
            glyph_geoip_tor="${glyph_geoip_tor} "

        geoip_tor="$(echo "$geoip_tor" | \
            awk \
                -v glyph="$glyph_geoip_tor"\
                'BEGIN { FS=OFS=", " }\
                /^GeoIP/ {print glyph tolower($2)}' |\
                tr -d 'eioa')"
# 
        netspeed=$(netspeed --compact enp3s0)
        [ -n "$netspeed" ] && netspeed=" $netspeed"

        [ "$ip_direct" = "" ] && geoip_direct="$ip_direct"
        [ "$ip_tor" = "" ] && geoip_tor="$ip_tor"
        echo "$geoip_direct"
        echo "$geoip_tor"
        echo "$netspeed"
    fi

}
######




######
# Now for the dirty background detail:
# Refresh and write the constructed statusbar
refresh_bar_all() {
    refresh_widgets_all
    build_bar
    write_bar
    # Save these widget's output to use them in refresh_widgets_set2
    geoip_last_output="${WIDGET[$widpos_geoip]}"
    mem_last_output="${WIDGET[$widpos_mem]}"
}

refresh_bar_set1() {
    refresh_widgets_set1
    build_bar
    write_bar
    # Save these widget's output to use them in refresh_widgets_set2
    mem_last_output="${WIDGET[$widpos_mem]}"
}

# Refresh and write the constructed statusbar (but only refresh set2)
refresh_bar_set2() {
    refresh_widgets_set2
    WIDGET[$widpos_geoip]="$geoip_last_output"
    WIDGET[$widpos_mem]="$mem_last_output"
    build_bar
    write_bar
}

# Refresh and write the constructed statusbar (but only refresh set2)
refresh_bar_set3() {
    refresh_widgets_set3
    build_bar
    write_bar
    # Save these widget's output to use them in refresh_widgets_set2
    geoip_last_output="${WIDGET[$widpos_geoip]}"
}

# Stick all the widgets together into a line
build_bar() {
    local widget_count="${#WIDGET[@]}"
    statusbar=$(for ((i = "$widget_count"; i > 0; i--))
    do
        echo "$delimiter"
        echo "${WIDGET[$i]}"
    done)
# Remove the first six characters of statusbar (leftover of the delimiter)
    statusbar="${bar_prefix}${statusbar:6}${enddelimiter}"
}

# Write the bar to dwm via xsetroot
write_bar() {
    xsetroot -name "$(echo -e "$statusbar" | tr -d '\n')" &
    wait
}
######

# Trap for updating the statusbar at will
trap 'refresh_bar_set2' SIGTRAP
trap 'refresh_bar_set3' SIGALRM

# Run the main function
main "$@"; exit
